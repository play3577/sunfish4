/* ZobristCodeGenerator.cpp
 *
 * Kubo Ryosuke
 */

#include "dev/code_generator/ZobristCodeGenerator.hpp"
#include "common/math/Random.hpp"
#include "core/base/Square.hpp"
#include "core/base/Piece.hpp"

namespace {

using namespace sunfish;

const uint64_t ZobristHashMask = 0xfffffffffffffffe;

const char* OutputPath = "src/core/position/Zobrist.cpp";

void generateZobristOnBoard(Random& random, std::ostream& os) {
  os << "const Zobrist::Type Zobrist::Board[Square::N][32] = {\n";
  SQUARE_EACH(square) {
    os << "  {\n";
    for (PieceRawType piece = PieceNumber::Begin; piece != PieceNumber::End; piece++) {
      uint64_t hash = random.int64() & ZobristHashMask;
      os << "    0x" << std::hex << hash << "ll,\n";
    }
    os << "  },\n";
  }
  os << "};\n";
}

void generateZobristOnHand(Random& random, const char* color, std::ostream& os) {
  const int num = 7;
  os << "const Zobrist::Type Zobrist::" << color << "Hand[" << std::dec << num << "] = {\n";
  for (int i = 0; i < num; i++) {
    uint64_t hash = random.int64() & ZobristHashMask;
    os << "  0x" << std::hex << hash << "ll,\n";
  }
  os << "};\n";
}

} // namespace

namespace sunfish {

ZobristCodeGenerator::ZobristCodeGenerator() :
  CodeGenerator(OutputPath) {
}

bool ZobristCodeGenerator::generateIntoStream(std::ostream& os) {
  os << "/* Zobrist.cpp \n";
  os << " * \n";
  os << " * generated by ZobristCodeGenerator\n";
  os << " */\n";
  os << "\n";
  os << "#include \"core/position/Zobrist.hpp\"";
  os << "\n";
  os << "namespace sunfish {\n";
  os << "\n";

  Random random;

  generateZobristOnBoard(random, os);

  os << "\n";

  generateZobristOnHand(random, "Black", os);
  generateZobristOnHand(random, "White", os);

  os << "\n";
  os << "} // namespace sunfish\n";

  return true;
}

} // namespace sunfish
